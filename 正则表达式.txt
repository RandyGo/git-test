正则就是用有限的符号，表达无限的序列

正则表达式的语法一般如下(js)，两条斜线中间是正则主体，这部分可以有很多字符组成；i部分是修饰符，i的意思表示忽略大小写

/^abc/i

1.简单字符

没有特殊意义的字符都是简单字符，简单字符就代表自身，绝大部分字符都是简单字符

/abc/   // 匹配 abc
/123/   // 匹配 123
/-_-/   // 匹配 -_-


2.转义字符


\n	匹配换行符
\r	匹配回车符
\t	匹配制表符，也就是tab键
\v	匹配垂直制表符
\x20	20是2位16进制数字，代表对应的字符
\u002B	002B是4位16进制数字，代表对应的字符
\u002B	002B是4位16进制数字，代表对应的字符
\w	匹配任何一个字母或者数字或者下划线
\W	匹配任何一个字母或者数字或者下划线以外的字符
\s	匹配空白字符，如空格，tab等
\S	匹配非空白字符
\d	匹配数字字符，0~9
\D	匹配非数字字符
\b	匹配单词的边界
\B	匹配非单词边界
\\	匹配\本身



3.字符集和

有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[]分隔，下面的代码能够匹配a或b或c

[abc]

如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同

[0123456789]
[0-9]

在前面添加^，可表示非的意思，下面的代码能够匹配abc之外的任意字符

[^abc]


其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集

. 匹配除了换行符（\n）以外的任意一个字符 = [^\n]
\w = [0-9a-zA-Z_]
\W = [^0-9a-zA-Z_]
\s = [ \t\n\v]
\S = [^ \t\n\v]
\d = [0-9]
\D = [^0-9]



4.量词

如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、*、{n}、{m,n}、{m,}

{n}匹配n次，比如a{2}，匹配aa

{m, n}匹配m-n次，优先匹配n次，比如a{1,3}，可以匹配aaa、aa、a

{m,}匹配m-∞次，优先匹配∞次，比如a{1,}，可以匹配aaaa...

?匹配0次或1次，优先匹配1次，相当于{0,1}

+匹配1-n次，优先匹配n次，相当于{1,}

*匹配0-n次，优先匹配n次，相当于{0,}

正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限

a{1, 3} // 匹配字符串'aaa'的话，会匹配aaa而不是a
有时候这不是我们想要的结果，可以在量词后面加上?，就可以开启非贪婪模式

a{1, 3}? // 匹配字符串'aaa'的话，会匹配a而不是aaa



5.字符边界

有时我们会有边界的匹配要求，比如以xxx开头，以xxx结尾

^在[]外表示匹配开头的意思
^abc // 可以匹配abc，但是不能匹配aabc

$表示匹配结尾的意思
abc$ // 可以匹配abc，但是不能匹配abcc

上面提到的\b表示单词的边界
abc\b // 可以匹配 abc ，但是不能匹配 abcc



6.选择表达式

有时我们想匹配x或者y，如果x和y是单个字符，可以使用字符集，[abc]可以匹配a或b或c，如果x和y是多个字符，字符集就无能为力了，此时就要用到分组

正则中用|来表示分组，a|b表示匹配a或者b的意思

123|456|789 // 匹配 123 或 456 或 789



7.分组与引用

分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)
(abc){2} // 匹配abcabc


分组不能放在[]中，分组中还可以使用选择表达式
(123|456){2} // 匹配 123123、456456、123456、456123

和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑
'123'.match(/(?:123)/) // 返回 ['123']
'123'.match(/(123)/)  // 返回 ['123', '123']

和分组相关的另一个概念是引用，比如在匹配html标签时，通常希望<xxx></xxx>后面的xxx能够和前面保持一致

引用的语法是\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用
<([a-z]+)><\/\1> // 可以匹配 `<span></span>` 或 `<div></div>`等



8.预搜索

如果你想匹配xxx前不能是yyy，或者xxx后不能是yyy，那就要用到预搜索

js只支持正向预搜索，也就是xxx后面必须是yyy，或者xxx后面不能是yyy

1(?=2) // 可以匹配12，不能匹配22
1(?!2) // 可有匹配22，不能匹配12


9.修饰符

默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下

/xxx/gi // 最后面的g和i就是两个修饰符
g正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束

i正则默认是区分大小写的，i可以忽略大小写

m正则默认情况下，^和$只能匹配字符串的开始和结尾，m修饰符可以让^和$匹配行首和行尾，不理解就看例子

/jing$/ // 能够匹配 'yanhaijing，不能匹配 'yanhaijing\n'
/jing$/m // 能够匹配 'yanhaijing， 能够匹配 'yanhaijing\n'

/^jing/ // 能够匹配 'jing'，不能匹配 '\njing'
/^jing/m // 能够匹配 'jing'，能够匹配 '\njing'
