版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库

git rebase --continue

git reset --hard HEAD^ 废除这次修改的记录，当前文件回到上一次提交的状态。
git reset --hard [commit版本号] --本地代码回滚
git reset --hard HEAD~3 将最近3次的提交回滚


git commit --amend 覆盖现在的分支最前面的提交

git log -p 文件地址  ===>查看文件修改记录

git checkout 文件名(地址) 忽略该文件的提交

git branch -D 分支名  删除本地分支

git pull origin 分支名  --->master下拉取一个新分支

gitk -->查看修改、提交等记录







2.4 检查仓库状态

git status 查看工作目录和缓存区

git log显示已提交的快照，只作用于提交的项目历史


用法：

git log 显示完整的项目历史，如果输出超过一屏，可用空格键来滚动，按q退出

git log -n <limit> 用<limit>限制提交的数量

git log --oneline 将每个提交压缩到一行，当需要查看项目历史的上层情况是会很有用

git log --stat  除git log信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数

git log -p 显示每个提交全部的差异(diff)

git log --author="<pattern>" 搜索特定作者的提交，<pattern>可以是字符串或者正则表达式

git log <file> 只显示包含特定文件的提交


2.5检出之前的提交

git checkout有3个不同的作用：检出文件、检出提交、检出分支

git checkout master 回到master分支

git checkout <commit> <file> 查看文件之前的版本(commit:提交版本号)，它将工作目录中的<file>文件变成<commit>中那个文件的拷贝，并将它加入缓存区

检出提交:

git checkout <commit> 更新工作目录中的所有文件，使得和某个特定提交中的文件一致。会切换到<commit>所在版本

检出文件:
如果只对某个文件感兴趣，可用git checkout来获取它的一个旧版本

git checkout <commit> <file>

和检出提交不同，这里确实会影响项目的当前状态，旧的文件版本会显示为[需要提交的更改]，允许你回滚到文件之前的版本。如果你不想保留就得版本，可以用下面的命令检出到最近的版本：

git checkout HEAD <file>



2.6回滚错误的修改

git revert用来撤销一个已经提交的快照。它并不会从项目历史中移除这个提交，只是撤销这个提交引入的更改，最后生成一个撤销更改后的新提交
用法
git revert <commit>
撤销了由<commit>引入的修改，生成一个新提交，然后应用到当前分支
撤销(revert)应该用在你想要在项目历史中移除一整个提交的时候，比如说，某个bug是由一个提交造成的，这时候撤销就很有用


git revert是一个撤销更改相对来说更安全的方式、而git reset就相对危险了，当我们使用git reset来重设更改时(提交不再被任何用或引用日志所引用),我们无法获得原来的样子――这个撤销是永远的，所以使用时务必要小心，这是少数几个可能造成工作丢失的命令之一。通常用来撤销缓存区和工作目录的修改，且只应被应用于本地修改――不要重设和其他开发者共享的快照。

用法：
git reset <file>
从缓存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不会覆盖任何更改。

git reset
重设缓存区，匹配最近的一次提交，工作目录不变。它会取消所有文件的缓存，不会覆盖任何更改，给了你一个重设缓存快照的机会。

git reset --hard

git reset --hard HEAD~2将当前分支向前倒退2个提交

重设缓存区和工作目录，匹配最近用的一次提交。除了取消缓存之外，--hard标记告诉Git还要重写所有工作目录中的更改。也就是说：它清除了所有未提交的更改(当次更改全部被清除)，所以在使用前要确定你想扔掉你所有本地的开发(本次提交的所有更改)

git reset <commit>-------------->这个比较实用！！！
将当前分支的末端移到<commit>,将缓存区重设到这个提交，但不会改变工作目录，即所有更改都保持不变。所有<commit>之后的更改会保留在工作目录中，这允许你用更干净的快照去重新提交项目历史，即重新构建提交来清理仓库，该<commit>之后的提交记录都将清除。

git reset --hard <commit>
将当前分支的末端移到<commit>，将缓存区和工作目录都重设到这个提交。它不仅清除了为提交的更改，同时还清除了<commit>之后的所有提交！！慎用！！




revert(撤销)和reset(重设)区别
git revert被设计为撤销公开的提交的安全方式，git reset 被设计为重设本地更改。两个命令的目的不同，因此实现也不一样。撤销(revert)保留了原来的更改，用一个新的提交来实现撤销，而重设(reset)完全地移除了一堆更改。

千万不要重设公共历史，当有<commit>之后的提交被推送到公共仓库后，绝不要用git reset。发布一个提交之后，必须假设其他开发者会依赖于它。

git clean
将未跟踪的文件从工作目录中移除。和一般的rm命令一样，git clean是无法撤销的，所以在删除未跟踪的文件之前要想清楚
git clean命令经常和git reset --hard一起使用。reset只影响被跟踪的文件，所以还需要一个单独的命令来清理未被跟踪的文件。两个命令相结合，可以将工作目录回到之前特定提交时的状态。

用法：
git clean -n 执行一次git clean的『演习』。它会告诉你那些文件在命令执行后会被移除，而不是真的删除它。

git clean -f
移除当前目录下未被跟踪的文件。-f（强制）标记是必需的，除非 clean.requireForce 配置项被设为了 false（默认为 true）。它 不会 删除 .gitignore 中指定的未跟踪的文件。

git clean -f <path>移除未跟踪的文件，但限制在某个路径下

git clean -df 移除未跟踪的文件，以及目录。

git clean -xf 移除当前目录下未跟踪的文件，以及 Git 一般忽略的文件。



2.7重写项目历史(修改提交信息)

git commit --amend

git commit --amend --no-edit  修复提交，但不修改提交信息

git commit --amend -m "new commit message"  修改提交信息

以上前提是还没有push到仓库当中，只在本地提交

注意：不要修复公共提交


git rebase
变基（rebase）是将分支移到一个新的基提交的过程
